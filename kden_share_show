#!/bin/bash
web_browser=firefox
image_browser="eom --fullscreen"
download_dirname=kdec_share_show

download_path="$XDG_RUNTIME_DIR/$download_dirname"


help() {
    echo -e "Share&Show script for KDE Connect Linux App
Script intended to run on linux HTPC alongside KDE Connect linux app
so it can show media shared on Android KDE Connect App on PC fullscreen.

Script detects if shared content is a file or an url. If it is an url, 
then script checks if url can be opened by youtube-dl. If so, then url is opened 
by smplayer (which uses youtube-dl).
If youtube-dl is not supporting that url, then it is opened by $web_browser.

If shared content is a file(s), then KDEConnect Linux App downloads that 
file to directory, which is detected by script (thanks to inotify).
If that file is an image, then it's opened by $image_browser.
If it's a video, then by smplayer.

Required packages: kdeconnect, inotify-tools, smplayer, $(echo "$image_browser" | cut -d' ' -f1)

Prepariation:
1. Set up a connection between linux KDE Connect and android KDE Connect

2. In linux KDEConnect Settings/[Phone Selection]/Share and Receive/[Settings button]
set path:
$download_path

3. Change linux default web browser to $0
In example, in XFCE: run xfce4-settings-manager,
In 'Preferred Applications' / 'Web Browser' choose 'Other...'
Type '$(realpath "$0") --urlopen', click OK

4. Run $0 --watch

5. On Android: choose image/youtube link and share it with KDE Connect

OPTIONS:
\t --watch 
\t     Watch $download_path for new images and movies using inotify-watch. 
\t     Then open it with $0 --fileopen

\t --fileopen FILE 
\t     Open FILE with smplayer, if it's a sound or movie,
\t     or with $image_browser - if it's an image.

\t --urlopen URL 
\t     Try if URL is supported by youtube-dl. If yes - open URL with 
\t     smplayer. If not - open URL with $web_browser

\t --closeall
\t     Close all instances of $0 --fileopen and $0 --urlopen
\t     Can be used by Android KDE Connect Commands plugin.

\t --clear-tmpdir
\t     Removes all files downloaded to temp dir: $download_path

\t -v, --verbose
\t     Enable verbose mode

\t -h, --help
\t     Display this help."
}

debug() {
    #if variable DEBUG is set, then prints to stderr
    #can use standard echo parameters
    #extra parameters: -d,-t - adds date; -f - adds parent function name
    [[ "$DEBUG" ]] || return
    
    while [ $# -gt 0 ]; do
        case "$1" in
            -d|-t) local debug_date="[$(date +'%F %X' )] " ;;
            -f) local debug_function="{${FUNCNAME[1]}}: " ;;
            -*) [[ "${#debug_args[@]}" -eq 0 ]] && local debug_args=( )
                debug_args+=("$1") ;;
            *)  break;;
        esac
        shift
    done

    echo "${debug_args[@]}" "$(tput setaf 1)${debug_date}${debug_function}$*$(tput sgr 0)" >&2
}

watchdir() {
    local file filepath i
    
    debug -f "$(mkdir -vp "$download_path/downloaded" )"
    cd "$download_path" || exit
    
    while read -r file; do
	debug -f -d "$file detected"
	if [[ "$file" =~ .part$ ]]; then
	    file="$(echo "$file" | sed 's#\.part$##')"
	    debug -f "changed name: $file"
	    for (( i=1; i<=10; i++ )); do
		#waiting for downloaded 'file.part' filename to change to 'file'
		[[ -f "$file" ]] && break
		sleep 0.1
		debug -n '.'
	    done

	    if [[ -f "$file" ]]; then
		debug -f "$file downloaded"
		filepath="${download_path}/downloaded/$(basename "$file")"
		mkdir -vp "$download_path/downloaded"
		debug -f "$(mv -v "$file" "$filepath" )"
		debug -f "opening file $filepath..."
		"$0" --fileopen "$filepath" &
	    else
		debug -f "Error downloading file '$file'"
	    fi
	fi
	    
    done< <(inotifywait \
		--monitor \
		--quiet \
		--event close_write \
		--format %f \
		"$download_path")
}

clear_tmpdir() {
    if ! [[ -d "$download_path" ]]; then
	ls "$download_path"
	exit 1
    fi

    rm -rv "${download_path:?}"/*
}
    

fileopen() {
    local file gnufile_output
    cd "$download_path" || exit
    file="$1"

    if ! [[ -s "$file" ]]; then
	echo "'$file' doesn't exist or empty!" >&2
	exit 1
    fi
    
    gnufile_output="$(file --mime --no-pad "$file" | cut -d ':' -f 2- )"
    debug -f "${file}: ${gnufile_output}"
    
    if echo "$gnufile_output" |\
	    grep -iwq 'media\|multimedia\|video\|sound'; then
	debug -f "opening with video player..."
	smplayer -fullscreen "$file"
    elif echo "$gnufile_output" |\
	    grep -iwq 'image'; then
	debug -f "opening with image viewer"
	$image_browser "$file"
    else
	echo -e "Unknown file type: '$file' \n${gnufile_output}"
	exit 1
    fi
    

}

while [ $# -gt 0 ]; do
    case "$1" in
        --watch)  watchdir ;;
        --fileopen)  fileopen "$2" ; shift;;
	--clear-tmpdir) clear_tmpdir ;;
        -h|--help)  help; exit;;
	-v|--verbose) export DEBUG=1 ;;
        --)  shift; break;;
        -*)  help           
            exit 1;;
        *)  break;;# terminate while loop
    esac
    shift
    # all command line switches are processed,
    # "$@" contains all file names
done
